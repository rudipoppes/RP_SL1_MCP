import { promises as fs } from 'fs';
import { resolve } from 'path';
/**
 * TypeScript type generator from OpenAPI specification
 * Follows professional standards for type generation and code quality
 */
class TypeGenerator {
    swaggerPath;
    document;
    processedSchemas = new Set();
    generatedTypes = new Set();
    constructor(swaggerPath) {
        this.swaggerPath = swaggerPath;
        this.document = {};
    }
    /**
     * Generate TypeScript types from swagger specification
     */
    async generateTypes() {
        console.log('üîß Loading OpenAPI specification...');
        await this.loadSwaggerSpec();
        console.log('üìã Analyzing API structure...');
        const stats = this.analyzeAPIStructure();
        console.log(`   Found ${stats.paths} paths, ${stats.schemas} schemas, ${stats.tags} tags`);
        console.log('üèóÔ∏è  Generating TypeScript types...');
        let output = this.generateHeader();
        // Generate primitive types first
        output += this.generatePrimitiveTypes();
        // Generate schema types
        if (this.document.components?.schemas) {
            output += this.generateSchemaTypes();
        }
        // Generate parameter types
        output += this.generateParameterTypes();
        // Generate response types
        output += this.generateResponseTypes();
        // Generate endpoint types
        output += this.generateEndpointTypes();
        // Generate tag-related types
        output += this.generateTagTypes();
        output += this.generateFooter();
        console.log('‚úÖ TypeScript types generated successfully!');
        return output;
    }
    /**
     * Load and parse swagger specification
     */
    async loadSwaggerSpec() {
        try {
            const swaggerContent = await fs.readFile(this.swaggerPath, 'utf-8');
            this.document = JSON.parse(swaggerContent);
            if (!this.document.openapi) {
                throw new Error('Invalid OpenAPI specification: missing openapi field');
            }
        }
        catch (error) {
            throw new Error(`Failed to load swagger specification: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Analyze API structure and return statistics
     */
    analyzeAPIStructure() {
        const paths = Object.keys(this.document.paths || {}).length;
        const schemas = Object.keys(this.document.components?.schemas || {}).length;
        const tags = (this.document.tags || []).length;
        return { paths, schemas, tags };
    }
    /**
     * Generate file header with documentation
     */
    generateHeader() {
        const now = new Date().toISOString();
        return `/**
 * AUTOGENERATED TYPESCRIPT TYPES FROM RESTOREPOINT API
 * Generated on: ${now}
 * Source: ${this.swaggerPath}
 * API Version: ${this.document.info.version}
 * 
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - This file is generated by scripts/generate-types.ts
 * 
 * This file contains TypeScript type definitions generated from the Restorepoint OpenAPI
 * specification. These types provide compile-time safety and IDE support for API interactions.
 * 
 * Usage:
 * import type { Device, Backup, ApiResponse } from './types/restorepoint-api.js';
 */

/**
 * API version information
 */
export const API_INFO = {
  title: '${this.document.info.title}',
  version: '${this.document.info.version}',
  description: ${this.document.info.description ? `'${this.document.info.description.replace(/'/g, "\\'")}'` : 'undefined'},
} as const;

`;
    }
    /**
     * Generate primitive type aliases
     */
    generatePrimitiveTypes() {
        return `
/**
 * Primitive type aliases for common API types
 */
export type DeviceId = string;
export type BackupId = string;
export type TaskId = string;
export type AgentId = string;
export type CommandId = string;
export type UserId = string;
export type CredentialId = string;

/**
 * Date and time types
 */
export type Timestamp = string; // ISO 8601 timestamp
export type CronExpression = string; // Cron-like schedule expression

/**
 * Status enumerations
 */
export type TaskStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled' | 'timeout';
export type DeviceStatus = 'online' | 'offline' | 'unknown' | 'maintenance';
export type BackupStatus = 'completed' | 'failed' | 'in_progress' | 'cancelled';
export type AgentStatus = 'online' | 'offline' | 'connecting' | 'error';

/**
 * Pagination types
 */
export interface PaginationParams {
  readonly limit?: number;
  readonly offset?: number;
  readonly sortBy?: string;
  readonly sortOrder?: 'asc' | 'desc';
}

export interface PaginationMeta {
  readonly offset: number;
  readonly limit: number;
  readonly total: number;
}

/**
 * Generic API response wrapper
 */
export interface ApiResponse<T = unknown> {
  readonly success: boolean;
  readonly data?: T;
  readonly message?: string;
  readonly errors?: Record<string, readonly string[]>;
  readonly metadata?: {
    readonly offset?: number;
    readonly limit?: number;
    readonly total?: number;
  };
}

/**
 * Paginated response wrapper
 */
export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  readonly metadata: PaginationMeta;
}

`;
    }
    /**
     * Generate types from component schemas
     */
    generateSchemaTypes() {
        if (!this.document.components?.schemas) {
            return '';
        }
        let output = '\n/**\n * Component schema types\n */\n';
        for (const [schemaName, schema] of Object.entries(this.document.components.schemas)) {
            if (this.generatedTypes.has(schemaName)) {
                continue;
            }
            const typeName = this.toPascalCase(schemaName);
            output += this.generateSchemaType(typeName, schema);
            this.generatedTypes.add(typeName);
        }
        return output;
    }
    /**
     * Generate type from OpenAPI schema
     */
    generateSchemaType(typeName, schema, depth = 0) {
        if (depth > 10) {
            console.warn(`Maximum recursion depth exceeded for type: ${typeName}`);
            return `// Type ${typeName} too complex to generate\n`;
        }
        let output = '';
        // Add documentation
        if (schema.description) {
            output += `/**\n * ${schema.description}\n */\n`;
        }
        // Handle referenced schema
        if (schema.$ref) {
            const refTypeName = this.getRefTypeName(schema.$ref);
            return `export type ${typeName} = ${refTypeName};\n\n`;
        }
        // Handle enum type
        if (schema.enum) {
            const enumValues = schema.enum.map(value => `'${value}'`).join(' | ');
            output += `export type ${typeName} = ${enumValues};\n\n`;
            return output;
        }
        // Handle primitive types
        if (schema.type && this.isPrimitiveType(schema.type)) {
            const tsType = this.mapPrimitiveType(schema.type, schema.format);
            output += `export type ${typeName} = ${tsType};\n\n`;
            return output;
        }
        // Handle object type
        if (schema.type === 'object' || schema.properties || schema.allOf) {
            output += this.generateObjectType(typeName, schema, depth);
            return output;
        }
        // Handle array type
        if (schema.type === 'array' || schema.items) {
            const itemType = schema.items ?
                this.generateInlineType(schema.items, depth + 1) :
                'unknown';
            output += `export type ${typeName} = ${itemType}[];\n\n`;
            return output;
        }
        // Fallback
        output += `export type ${typeName} = unknown;\n\n`;
        return output;
    }
    /**
     * Generate object type from schema
     */
    generateObjectType(typeName, schema, depth) {
        let output = `export interface ${typeName} {\n`;
        // Handle allOf (inheritance)
        if (schema.allOf) {
            for (const allOfSchema of schema.allOf) {
                if (allOfSchema.$ref) {
                    const refTypeName = this.getRefTypeName(allOfSchema.$ref);
                    output += `  extends ${refTypeName}\n`;
                }
                else if (allOfSchema.properties) {
                    for (const [propName, propSchema] of Object.entries(allOfSchema.properties)) {
                        output += this.generateProperty(propName, propSchema, allOfSchema.required?.includes(propName), depth);
                    }
                }
            }
        }
        // Handle properties
        if (schema.properties) {
            for (const [propName, propSchema] of Object.entries(schema.properties)) {
                output += this.generateProperty(propName, propSchema, schema.required?.includes(propName), depth);
            }
        }
        output += '}\n\n';
        return output;
    }
    /**
     * Generate property line for interface
     */
    generateProperty(propertyName, propertySchema, required = false, depth) {
        const propName = this.escapePropertyName(propertyName);
        const optional = !required ? '?' : '';
        const propertyType = this.generateInlineType(propertySchema, depth + 1);
        const comment = propertySchema.description ? `  /** ${propertySchema.description} */\n` : '';
        return `${comment}  readonly ${propName}${optional}: ${propertyType};\n`;
    }
    /**
     * Generate inline type (not named)
     */
    generateInlineType(schema, depth) {
        if (depth > 5) {
            return 'unknown';
        }
        // Handle reference
        if (schema.$ref) {
            return this.getRefTypeName(schema.$ref);
        }
        // Handle enum
        if (schema.enum) {
            return schema.enum.map(value => `'${value}'`).join(' | ');
        }
        // Handle primitive
        if (schema.type && this.isPrimitiveType(schema.type)) {
            return this.mapPrimitiveType(schema.type, schema.format);
        }
        // Handle array
        if (schema.type === 'array' || schema.items) {
            const itemType = schema.items ?
                this.generateInlineType(schema.items, depth + 1) :
                'unknown';
            return `${itemType}[]`;
        }
        // Handle object
        if (schema.type === 'object' || schema.properties) {
            if (!schema.properties) {
                return 'Record<string, unknown>';
            }
            const props = Object.entries(schema.properties).map(([propName, propSchema]) => {
                const optional = !schema.required?.includes(propName);
                const propType = this.generateInlineType(propSchema, depth + 1);
                return `readonly ${propName}${optional ? '?' : ''}: ${propType}`;
            });
            return `{\n  ${props.join('\n  ')}\n}`;
        }
        return 'unknown';
    }
    /**
     * Generate parameter types
     */
    generateParameterTypes() {
        // Generate common parameter types based on the spec analysis
        return `
/**
 * Common query parameters
 */
export interface CommonQueryParams extends PaginationParams {
  readonly filter?: string;
  readonly search?: string;
  readonly fields?: string;
}

/**
 * Device query parameters
 */
export interface DeviceQueryParams extends CommonQueryParams {
  readonly type?: string;
  readonly status?: DeviceStatus;
  readonly domainId?: string;
}

/**
 * Backup query parameters
 */
export interface BackupQueryParams extends CommonQueryParams {
  readonly deviceId?: DeviceId;
  readonly status?: BackupStatus;
  readonly dateFrom?: Timestamp;
  readonly dateTo?: Timestamp;
}

`;
    }
    /**
     * Generate response types
     */
    generateResponseTypes() {
        return `
/**
 * API response types for different endpoints
 */
export interface DeviceListResponse extends PaginatedResponse<Device> {}
export interface DeviceResponse extends ApiResponse<Device> {}
export interface BackupListResponse extends PaginatedResponse<Backup> {}
export interface BackupResponse extends ApiResponse<Backup> {}
export interface TaskResponse extends ApiResponse<TaskInfo> {}
export interface AgentListResponse extends PaginatedResponse<Agent> {}
export interface AgentResponse extends ApiResponse<Agent> {}

/**
 * Operation result types
 */
export interface AsyncOperationResult {
  readonly success: true;
  readonly taskId: TaskId;
  readonly message: string;
  readonly estimatedTime?: string;
}

export interface TaskProgressResult {
  readonly taskId: TaskId;
  readonly status: TaskStatus;
  readonly progress: number; // 0-100
  readonly message: string;
  readonly startTime: Timestamp;
  readonly endTime?: Timestamp;
  readonly result?: unknown;
  readonly error?: string;
}

`;
    }
    /**
     * Generate endpoint-related types
     */
    generateEndpointTypes() {
        if (!this.document.paths) {
            return '';
        }
        let output = '\n/**\n * Endpoint operation types\n */\n';
        // Extract unique operation patterns
        const operations = new Set();
        for (const [path, pathItem] of Object.entries(this.document.paths)) {
            for (const method of ['get', 'post', 'put', 'patch', 'delete']) {
                if (pathItem[method]) {
                    operations.add(method);
                }
            }
        }
        for (const operation of operations) {
            output += `export type ${operation.charAt(0).toUpperCase() + operation.slice(1)}Operation = {\n`;
            output += `  readonly method: '${operation}';\n`;
            output += `  readonly path: string;\n`;
            output += `  readonly parameters?: Record<string, unknown>;\n`;
            output += `  readonly body?: unknown;\n`;
            output += `};\n\n`;
        }
        return output;
    }
    /**
     * Generate tag-related types
     */
    generateTagTypes() {
        if (!this.document.tags || this.document.tags.length === 0) {
            return '';
        }
        let output = '\n/**\n * API tag types for organizing endpoints\n */\n';
        const tagNames = this.document.tags.map(tag => tag.name);
        const tagUnion = tagNames.map(name => `'${name}'`).join(' | ');
        output += `export type ApiTag = ${tagUnion};\n\n`;
        // Generate tag interfaces
        for (const tag of this.document.tags) {
            const tagName = this.toPascalCase(tag.name);
            output += `/**\n * ${tag.description || `${tag.name} operations`}\n */\n`;
            output += `export interface ${tagName}Tag {\n`;
            output += `  readonly name: '${tag.name}';\n`;
            output += `  readonly description: ${tag.description ? `'${tag.description.replace(/'/g, "\\'")}'` : 'undefined'};\n`;
            output += `}\n\n`;
        }
        return output;
    }
    /**
     * Generate footer with helper utilities
     */
    generateFooter() {
        return `
/**
 * Type guards and utilities
 */
export const isTaskStatus = (value: unknown): value is TaskStatus => {
  return typeof value === 'string' && 
    ['pending', 'running', 'completed', 'failed', 'cancelled', 'timeout'].includes(value);
};

export const isDeviceStatus = (value: unknown): value is DeviceStatus => {
  return typeof value === 'string' && 
    ['online', 'offline', 'unknown', 'maintenance'].includes(value);
};

export const isBackupStatus = (value: unknown): value is BackupStatus => {
  return typeof value === 'string' && 
    ['completed', 'failed', 'in_progress', 'cancelled'].includes(value);
};

/**
 * Utility type for partial updates
 */
export type PartialUpdate<T> = {
  readonly [P in keyof T]?: T[P];
};

/**
 * Utility type for required fields
 */
export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

/**
 * End of generated types
 */
`;
    }
    /**
     * Helper methods
     */
    getRefTypeName(ref) {
        // Extract type name from $ref path
        const parts = ref.split('/');
        const baseName = parts[parts.length - 1];
        return this.toPascalCase(baseName);
    }
    toPascalCase(str) {
        return str
            .replace(/[^a-zA-Z0-9]/g, ' ')
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
    }
    escapePropertyName(propName) {
        // Escape TypeScript keywords and invalid identifiers
        const tsKeywords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger',
            'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false',
            'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new',
            'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try',
            'typeof', 'var', 'void', 'while', 'with', 'as', 'implements', 'interface',
            'let', 'package', 'private', 'protected', 'public', 'static', 'yield',
            'any', 'boolean', 'constructor', 'declare', 'get', 'module', 'require',
            'number', 'set', 'string', 'symbol', 'type', 'from', 'of'];
        if (tsKeywords.includes(propName) || !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propName)) {
            return `'${propName}'`;
        }
        return propName;
    }
    isPrimitiveType(type) {
        return ['string', 'number', 'integer', 'boolean', 'null'].includes(type);
    }
    mapPrimitiveType(type, format) {
        const typeMap = {
            'string': format === 'date-time' ? 'Date' : format === 'date' ? 'Date' : 'string',
            'number': 'number',
            'integer': 'number',
            'boolean': 'boolean',
            'null': 'null',
        };
        return typeMap[type] || 'unknown';
    }
}
/**
 * Main execution function
 */
async function main() {
    try {
        const swaggerPath = resolve(process.cwd(), 'swagger-2.json');
        const outputPath = resolve(process.cwd(), 'src/types/restorepoint-api.ts');
        console.log('üöÄ Starting TypeScript type generation from OpenAPI specification...');
        console.log(`   Source: ${swaggerPath}`);
        console.log(`   Output: ${outputPath}`);
        const generator = new TypeGenerator(swaggerPath);
        const generatedTypes = await generator.generateTypes();
        // Ensure output directory exists
        await fs.mkdir(resolve(outputPath, '..'), { recursive: true });
        // Write generated types to file
        await fs.writeFile(outputPath, generatedTypes, 'utf-8');
        console.log('üéâ Type generation completed successfully!');
        console.log(`   Generated file: ${outputPath}`);
        console.log(`   File size: ${Math.round(generatedTypes.length / 1024)} KB`);
    }
    catch (error) {
        console.error('‚ùå Type generation failed:', error instanceof Error ? error.message : 'Unknown error');
        process.exit(1);
    }
}
// Run if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}
//# sourceMappingURL=generate-types.js.map