import { promises as fs } from 'fs';
import { resolve } from 'path';

/**
 * Interface for OpenAPI schema definitions
 */
interface OpenAPISchema {
  type?: string;
  format?: string;
  properties?: Record<string, OpenAPISchema>;
  items?: OpenAPISchema;
  required?: string[];
  enum?: readonly string[];
  $ref?: string;
  allOf?: OpenAPISchema[];
  oneOf?: OpenAPISchema[];
  anyOf?: OpenAPISchema[];
  description?: string;
  example?: unknown;
}

interface OpenAPIParameter {
  name: string;
  in: 'query' | 'path' | 'header' | 'cookie';
  description?: string;
  required?: boolean;
  schema: OpenAPISchema;
}

interface OpenAPIResponse {
  description?: string;
  content?: Record<string, { schema?: OpenAPISchema }>;
}

interface OpenAPIOperation {
  operationId?: string;
  summary?: string;
  description?: string;
  tags?: readonly string[];
  parameters?: readonly OpenAPIParameter[];
  requestBody?: {
    content?: Record<string, { schema?: OpenAPISchema }>;
  };
  responses?: Record<string, OpenAPIResponse>;
}

interface OpenAPIPathItem {
  get?: OpenAPIOperation;
  post?: OpenAPIOperation;
  put?: OpenAPIOperation;
  patch?: OpenAPIOperation;
  delete?: OpenAPIOperation;
}

interface OpenAPIDocument {
  openapi: string;
  info: {
    title: string;
    version: string;
    description?: string;
  };
  servers?: readonly { url: string }[];
  paths?: Record<string, OpenAPIPathItem>;
  components?: {
    schemas?: Record<string, OpenAPISchema>;
  };
  tags?: readonly { name: string; description?: string }[];
}

/**
 * TypeScript type generator from OpenAPI specification
 * Follows professional standards for type generation and code quality
 */
class TypeGenerator {
  private readonly document: OpenAPIDocument;
  private readonly processedSchemas = new Set<string>();
  private readonly generatedTypes = new Set<string>();

  constructor(private readonly swaggerPath: string) {
    this.document = {} as OpenAPIDocument;
  }

  /**
   * Generate TypeScript types from swagger specification
   */
  public async generateTypes(): Promise<string> {
    console.log('üîß Loading OpenAPI specification...');
    await this.loadSwaggerSpec();

    console.log('üìã Analyzing API structure...');
    const stats = this.analyzeAPIStructure();
    console.log(`   Found ${stats.paths} paths, ${stats.schemas} schemas, ${stats.tags} tags`);

    console.log('üèóÔ∏è  Generating TypeScript types...');
    let output = this.generateHeader();

    // Generate primitive types first
    output += this.generatePrimitiveTypes();

    // Generate schema types
    if (this.document.components?.schemas) {
      output += this.generateSchemaTypes();
    }

    // Generate parameter types
    output += this.generateParameterTypes();

    // Generate response types
    output += this.generateResponseTypes();

    // Generate endpoint types
    output += this.generateEndpointTypes();

    // Generate tag-related types
    output += this.generateTagTypes();

    output += this.generateFooter();

    console.log('‚úÖ TypeScript types generated successfully!');
    return output;
  }

  /**
   * Load and parse swagger specification
   */
  private async loadSwaggerSpec(): Promise<void> {
    try {
      const swaggerContent = await fs.readFile(this.swaggerPath, 'utf-8');
      this.document = JSON.parse(swaggerContent);
      
      if (!this.document.openapi) {
        throw new Error('Invalid OpenAPI specification: missing openapi field');
      }
    } catch (error) {
      throw new Error(`Failed to load swagger specification: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Analyze API structure and return statistics
   */
  private analyzeAPIStructure(): {
    readonly paths: number;
    readonly schemas: number;
    readonly tags: number;
  } {
    const paths = Object.keys(this.document.paths || {}).length;
    const schemas = Object.keys(this.document.components?.schemas || {}).length;
    const tags = (this.document.tags || []).length;

    return { paths, schemas, tags };
  }

  /**
   * Generate file header with documentation
   */
  private generateHeader(): string {
    const now = new Date().toISOString();
    return `/**
 * AUTOGENERATED TYPESCRIPT TYPES FROM RESTOREPOINT API
 * Generated on: ${now}
 * Source: ${this.swaggerPath}
 * API Version: ${this.document.info.version}
 * 
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - This file is generated by scripts/generate-types.ts
 * 
 * This file contains TypeScript type definitions generated from the Restorepoint OpenAPI
 * specification. These types provide compile-time safety and IDE support for API interactions.
 * 
 * Usage:
 * import type { Device, Backup, ApiResponse } from './types/restorepoint-api.js';
 */

/**
 * API version information
 */
export const API_INFO = {
  title: '${this.document.info.title}',
  version: '${this.document.info.version}',
  description: ${this.document.info.description ? `'${this.document.info.description.replace(/'/g, "\\'")}'` : 'undefined'},
} as const;

`;
  }

  /**
   * Generate primitive type aliases
   */
  private generatePrimitiveTypes(): string {
    return `
/**
 * Primitive type aliases for common API types
 */
export type DeviceId = string;
export type BackupId = string;
export type TaskId = string;
export type AgentId = string;
export type CommandId = string;
export type UserId = string;
export type CredentialId = string;

/**
 * Date and time types
 */
export type Timestamp = string; // ISO 8601 timestamp
export type CronExpression = string; // Cron-like schedule expression

/**
 * Status enumerations
 */
export type TaskStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled' | 'timeout';
export type DeviceStatus = 'online' | 'offline' | 'unknown' | 'maintenance';
export type BackupStatus = 'completed' | 'failed' | 'in_progress' | 'cancelled';
export type AgentStatus = 'online' | 'offline' | 'connecting' | 'error';

/**
 * Pagination types
 */
export interface PaginationParams {
  readonly limit?: number;
  readonly offset?: number;
  readonly sortBy?: string;
  readonly sortOrder?: 'asc' | 'desc';
}

export interface PaginationMeta {
  readonly offset: number;
  readonly limit: number;
  readonly total: number;
}

/**
 * Generic API response wrapper
 */
export interface ApiResponse<T = unknown> {
  readonly success: boolean;
  readonly data?: T;
  readonly message?: string;
  readonly errors?: Record<string, readonly string[]>;
  readonly metadata?: {
    readonly offset?: number;
    readonly limit?: number;
    readonly total?: number;
  };
}

/**
 * Paginated response wrapper
 */
export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  readonly metadata: PaginationMeta;
}

`;
  }

  /**
   * Generate types from component schemas
   */
  private generateSchemaTypes(): string {
    if (!this.document.components?.schemas) {
      return '';
    }

    let output = '\n/**\n * Component schema types\n */\n';

    for (const [schemaName, schema] of Object.entries(this.document.components.schemas)) {
      if (this.generatedTypes.has(schemaName)) {
        continue;
      }

      const typeName = this.toPascalCase(schemaName);
      output += this.generateSchemaType(typeName, schema);
      this.generatedTypes.add(typeName);
    }

    return output;
  }

  /**
   * Generate type from OpenAPI schema
   */
  private generateSchemaType(typeName: string, schema: OpenAPISchema, depth = 0): string {
    if (depth > 10) {
      console.warn(`Maximum recursion depth exceeded for type: ${typeName}`);
      return `// Type ${typeName} too complex to generate\n`;
    }

    let output = '';

    // Add documentation
    if (schema.description) {
      output += `/**\n * ${schema.description}\n */\n`;
    }

    // Handle referenced schema
    if (schema.$ref) {
      const refTypeName = this.getRefTypeName(schema.$ref);
      return `export type ${typeName} = ${refTypeName};\n\n`;
    }

    // Handle enum type
    if (schema.enum) {
      const enumValues = schema.enum.map(value => `'${value}'`).join(' | ');
      output += `export type ${typeName} = ${enumValues};\n\n`;
      return output;
    }

    // Handle primitive types
    if (schema.type && this.isPrimitiveType(schema.type)) {
      const tsType = this.mapPrimitiveType(schema.type, schema.format);
      output += `export type ${typeName} = ${tsType};\n\n`;
      return output;
    }

    // Handle object type
    if (schema.type === 'object' || schema.properties || schema.allOf) {
      output += this.generateObjectType(typeName, schema, depth);
      return output;
    }

    // Handle array type
    if (schema.type === 'array' || schema.items) {
      const itemType = schema.items ? 
        this.generateInlineType(schema.items, depth + 1) : 
        'unknown';
      output += `export type ${typeName} = ${itemType}[];\n\n`;
      return output;
    }

    // Fallback
    output += `export type ${typeName} = unknown;\n\n`;
    return output;
  }

  /**
   * Generate object type from schema
   */
  private generateObjectType(typeName: string, schema: OpenAPISchema, depth: number): string {
    let output = `export interface ${typeName} {\n`;

    // Handle allOf (inheritance)
    if (schema.allOf) {
      for (const allOfSchema of schema.allOf) {
        if (allOfSchema.$ref) {
          const refTypeName = this.getRefTypeName(allOfSchema.$ref);
          output += `  extends ${refTypeName}\n`;
        } else if (allOfSchema.properties) {
          for (const [propName, propSchema] of Object.entries(allOfSchema.properties)) {
            output += this.generateProperty(propName, propSchema, allOfSchema.required?.includes(propName), depth);
          }
        }
      }
    }

    // Handle properties
    if (schema.properties) {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        output += this.generateProperty(propName, propSchema, schema.required?.includes(propName), depth);
      }
    }

    output += '}\n\n';
    return output;
  }

  /**
   * Generate property line for interface
   */
  private generateProperty(
    propertyName: string,
    propertySchema: OpenAPISchema,
    required: boolean = false,
    depth: number
  ): string {
    const propName = this.escapePropertyName(propertyName);
    const optional = !required ? '?' : '';
    const propertyType = this.generateInlineType(propertySchema, depth + 1);
    const comment = propertySchema.description ? `  /** ${propertySchema.description} */\n` : '';

    return `${comment}  readonly ${propName}${optional}: ${propertyType};\n`;
  }

  /**
   * Generate inline type (not named)
   */
  private generateInlineType(schema: OpenAPISchema, depth: number): string {
    if (depth > 5) {
      return 'unknown';
    }

    // Handle reference
    if (schema.$ref) {
      return this.getRefTypeName(schema.$ref);
    }

    // Handle enum
    if (schema.enum) {
      return schema.enum.map(value => `'${value}'`).join(' | ');
    }

    // Handle primitive
    if (schema.type && this.isPrimitiveType(schema.type)) {
      return this.mapPrimitiveType(schema.type, schema.format);
    }

    // Handle array
    if (schema.type === 'array' || schema.items) {
      const itemType = schema.items ? 
        this.generateInlineType(schema.items, depth + 1) : 
        'unknown';
      return `${itemType}[]`;
    }

    // Handle object
    if (schema.type === 'object' || schema.properties) {
      if (!schema.properties) {
        return 'Record<string, unknown>';
      }

      const props = Object.entries(schema.properties).map(([propName, propSchema]) => {
        const optional = !schema.required?.includes(propName);
        const propType = this.generateInlineType(propSchema, depth + 1);
        return `readonly ${propName}${optional ? '?' : ''}: ${propType}`;
      });

      return `{\n  ${props.join('\n  ')}\n}`;
    }

    return 'unknown';
  }

  /**
   * Generate parameter types
   */
  private generateParameterTypes(): string {
    // Generate common parameter types based on the spec analysis
    return `
/**
 * Common query parameters
 */
export interface CommonQueryParams extends PaginationParams {
  readonly filter?: string;
  readonly search?: string;
  readonly fields?: string;
}

/**
 * Device query parameters
 */
export interface DeviceQueryParams extends CommonQueryParams {
  readonly type?: string;
  readonly status?: DeviceStatus;
  readonly domainId?: string;
}

/**
 * Backup query parameters
 */
export interface BackupQueryParams extends CommonQueryParams {
  readonly deviceId?: DeviceId;
  readonly status?: BackupStatus;
  readonly dateFrom?: Timestamp;
  readonly dateTo?: Timestamp;
}

`;
  }

  /**
   * Generate response types
   */
  private generateResponseTypes(): string {
    return `
/**
 * API response types for different endpoints
 */
export interface DeviceListResponse extends PaginatedResponse<Device> {}
export interface DeviceResponse extends ApiResponse<Device> {}
export interface BackupListResponse extends PaginatedResponse<Backup> {}
export interface BackupResponse extends ApiResponse<Backup> {}
export interface TaskResponse extends ApiResponse<TaskInfo> {}
export interface AgentListResponse extends PaginatedResponse<Agent> {}
export interface AgentResponse extends ApiResponse<Agent> {}

/**
 * Operation result types
 */
export interface AsyncOperationResult {
  readonly success: true;
  readonly taskId: TaskId;
  readonly message: string;
  readonly estimatedTime?: string;
}

export interface TaskProgressResult {
  readonly taskId: TaskId;
  readonly status: TaskStatus;
  readonly progress: number; // 0-100
  readonly message: string;
  readonly startTime: Timestamp;
  readonly endTime?: Timestamp;
  readonly result?: unknown;
  readonly error?: string;
}

`;
  }

  /**
   * Generate endpoint-related types
   */
  private generateEndpointTypes(): string {
    if (!this.document.paths) {
      return '';
    }

    let output = '\n/**\n * Endpoint operation types\n */\n';

    // Extract unique operation patterns
    const operations = new Set<string>();
    
    for (const [path, pathItem] of Object.entries(this.document.paths)) {
      for (const method of ['get', 'post', 'put', 'patch', 'delete'] as const) {
        if (pathItem[method]) {
          operations.add(method);
        }
      }
    }

    for (const operation of operations) {
      output += `export type ${operation.charAt(0).toUpperCase() + operation.slice(1)}Operation = {\n`;
      output += `  readonly method: '${operation}';\n`;
      output += `  readonly path: string;\n`;
      output += `  readonly parameters?: Record<string, unknown>;\n`;
      output += `  readonly body?: unknown;\n`;
      output += `};\n\n`;
    }

    return output;
  }

  /**
   * Generate tag-related types
   */
  private generateTagTypes(): string {
    if (!this.document.tags || this.document.tags.length === 0) {
      return '';
    }

    let output = '\n/**\n * API tag types for organizing endpoints\n */\n';

    const tagNames = this.document.tags.map(tag => tag.name);
    const tagUnion = tagNames.map(name => `'${name}'`).join(' | ');

    output += `export type ApiTag = ${tagUnion};\n\n`;

    // Generate tag interfaces
    for (const tag of this.document.tags) {
      const tagName = this.toPascalCase(tag.name);
      output += `/**\n * ${tag.description || `${tag.name} operations`}\n */\n`;
      output += `export interface ${tagName}Tag {\n`;
      output += `  readonly name: '${tag.name}';\n`;
      output += `  readonly description: ${tag.description ? `'${tag.description.replace(/'/g, "\\'")}'` : 'undefined'};\n`;
      output += `}\n\n`;
    }

    return output;
  }

  /**
   * Generate footer with helper utilities
   */
  private generateFooter(): string {
    return `
/**
 * Type guards and utilities
 */
export const isTaskStatus = (value: unknown): value is TaskStatus => {
  return typeof value === 'string' && 
    ['pending', 'running', 'completed', 'failed', 'cancelled', 'timeout'].includes(value);
};

export const isDeviceStatus = (value: unknown): value is DeviceStatus => {
  return typeof value === 'string' && 
    ['online', 'offline', 'unknown', 'maintenance'].includes(value);
};

export const isBackupStatus = (value: unknown): value is BackupStatus => {
  return typeof value === 'string' && 
    ['completed', 'failed', 'in_progress', 'cancelled'].includes(value);
};

/**
 * Utility type for partial updates
 */
export type PartialUpdate<T> = {
  readonly [P in keyof T]?: T[P];
};

/**
 * Utility type for required fields
 */
export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

/**
 * End of generated types
 */
`;
  }

  /**
   * Helper methods
   */

  private getRefTypeName(ref: string): string {
    // Extract type name from $ref path
    const parts = ref.split('/');
    const baseName = parts[parts.length - 1];
    return this.toPascalCase(baseName);
  }

  private toPascalCase(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private escapePropertyName(propName: string): string {
    // Escape TypeScript keywords and invalid identifiers
    const tsKeywords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 
                       'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 
                       'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 
                       'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try', 
                       'typeof', 'var', 'void', 'while', 'with', 'as', 'implements', 'interface', 
                       'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 
                       'any', 'boolean', 'constructor', 'declare', 'get', 'module', 'require', 
                       'number', 'set', 'string', 'symbol', 'type', 'from', 'of'];
    
    if (tsKeywords.includes(propName) || !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propName)) {
      return `'${propName}'`;
    }
    
    return propName;
  }

  private isPrimitiveType(type: string): boolean {
    return ['string', 'number', 'integer', 'boolean', 'null'].includes(type);
  }

  private mapPrimitiveType(type: string, format?: string): string {
    const typeMap: Record<string, string> = {
      'string': format === 'date-time' ? 'Date' : format === 'date' ? 'Date' : 'string',
      'number': 'number',
      'integer': 'number',
      'boolean': 'boolean',
      'null': 'null',
    };

    return typeMap[type] || 'unknown';
  }
}

/**
 * Main execution function
 */
async function main(): Promise<void> {
  try {
    const swaggerPath = resolve(process.cwd(), 'swagger-2.json');
    const outputPath = resolve(process.cwd(), 'src/types/restorepoint-api.ts');

    console.log('üöÄ Starting TypeScript type generation from OpenAPI specification...');
    console.log(`   Source: ${swaggerPath}`);
    console.log(`   Output: ${outputPath}`);

    const generator = new TypeGenerator(swaggerPath);
    const generatedTypes = await generator.generateTypes();

    // Ensure output directory exists
    await fs.mkdir(resolve(outputPath, '..'), { recursive: true });

    // Write generated types to file
    await fs.writeFile(outputPath, generatedTypes, 'utf-8');

    console.log('üéâ Type generation completed successfully!');
    console.log(`   Generated file: ${outputPath}`);
    console.log(`   File size: ${Math.round(generatedTypes.length / 1024)} KB`);

  } catch (error) {
    console.error('‚ùå Type generation failed:', error instanceof Error ? error.message : 'Unknown error');
    process.exit(1);
  }
}

// Run if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}